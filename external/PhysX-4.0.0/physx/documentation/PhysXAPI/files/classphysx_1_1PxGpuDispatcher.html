<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>physx::PxGpuDispatcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="PhysXLogoBlack.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classphysx_1_1PxGpuDispatcher.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classphysx_1_1PxGpuDispatcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">physx::PxGpuDispatcher Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A GpuTask dispatcher.  
 <a href="classphysx_1_1PxGpuDispatcher.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PxGpuDispatcher_8h_source.html">PxGpuDispatcher.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a091cb121a38ddf39fcab51f5118a15d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#a091cb121a38ddf39fcab51f5118a15d2">startSimulation</a> ()=0</td></tr>
<tr class="memdesc:a091cb121a38ddf39fcab51f5118a15d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the start of a simulation step.  <a href="#a091cb121a38ddf39fcab51f5118a15d2">More...</a><br /></td></tr>
<tr class="separator:a091cb121a38ddf39fcab51f5118a15d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f6db8b18cf8380967890d694e3df8e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#a86f6db8b18cf8380967890d694e3df8e">startGroup</a> ()=0</td></tr>
<tr class="memdesc:a86f6db8b18cf8380967890d694e3df8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the start of a GpuTask batch submission.  <a href="#a86f6db8b18cf8380967890d694e3df8e">More...</a><br /></td></tr>
<tr class="separator:a86f6db8b18cf8380967890d694e3df8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffc5d0c124afbcad0b6fcf1080af5ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#a5ffc5d0c124afbcad0b6fcf1080af5ee">submitTask</a> (<a class="el" href="classphysx_1_1PxTask.html">PxTask</a> &amp;task)=0</td></tr>
<tr class="memdesc:a5ffc5d0c124afbcad0b6fcf1080af5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a GpuTask for execution.  <a href="#a5ffc5d0c124afbcad0b6fcf1080af5ee">More...</a><br /></td></tr>
<tr class="separator:a5ffc5d0c124afbcad0b6fcf1080af5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec171af375195b782acce8fae4d2e93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#a2ec171af375195b782acce8fae4d2e93">finishGroup</a> ()=0</td></tr>
<tr class="memdesc:a2ec171af375195b782acce8fae4d2e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the end of a GpuTask batch submission.  <a href="#a2ec171af375195b782acce8fae4d2e93">More...</a><br /></td></tr>
<tr class="separator:a2ec171af375195b782acce8fae4d2e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c2631f98a92733515f59823787fdc7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#a27c2631f98a92733515f59823787fdc7">addCompletionPrereq</a> (<a class="el" href="classphysx_1_1PxBaseTask.html">PxBaseTask</a> &amp;task)=0</td></tr>
<tr class="memdesc:a27c2631f98a92733515f59823787fdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a CUDA completion prerequisite dependency to a task.  <a href="#a27c2631f98a92733515f59823787fdc7">More...</a><br /></td></tr>
<tr class="separator:a27c2631f98a92733515f59823787fdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad903de1449d82e6d9e51f610711f74d9"><td class="memItemLeft" align="right" valign="top">virtual PxCudaContextManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#ad903de1449d82e6d9e51f610711f74d9">getCudaContextManager</a> ()=0</td></tr>
<tr class="memdesc:ad903de1449d82e6d9e51f610711f74d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the PxCudaContextManager associated with this <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a>.  <a href="#ad903de1449d82e6d9e51f610711f74d9">More...</a><br /></td></tr>
<tr class="separator:ad903de1449d82e6d9e51f610711f74d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46896dea09105e1f5fc1d19a98f2b1b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#ab46896dea09105e1f5fc1d19a98f2b1b">stopSimulation</a> ()=0</td></tr>
<tr class="memdesc:ab46896dea09105e1f5fc1d19a98f2b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the end of a simulation frame.  <a href="#ab46896dea09105e1f5fc1d19a98f2b1b">More...</a><br /></td></tr>
<tr class="separator:ab46896dea09105e1f5fc1d19a98f2b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3157fe3020f29f2a4c3bdc5eb11b79c6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#a3157fe3020f29f2a4c3bdc5eb11b79c6">failureDetected</a> () const =0</td></tr>
<tr class="memdesc:a3157fe3020f29f2a4c3bdc5eb11b79c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a CUDA call has returned a non-recoverable error.  <a href="#a3157fe3020f29f2a4c3bdc5eb11b79c6">More...</a><br /></td></tr>
<tr class="separator:a3157fe3020f29f2a4c3bdc5eb11b79c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0310275811d2b9df30ef6dfeda59333b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#a0310275811d2b9df30ef6dfeda59333b">forceFailureMode</a> ()=0</td></tr>
<tr class="memdesc:a0310275811d2b9df30ef6dfeda59333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> into failure mode.  <a href="#a0310275811d2b9df30ef6dfeda59333b">More...</a><br /></td></tr>
<tr class="separator:a0310275811d2b9df30ef6dfeda59333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbc8264abbffb8075f37e2d61205671"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#a7dbc8264abbffb8075f37e2d61205671">launchCopyKernel</a> (PxGpuCopyDesc *desc, uint32_t count, <a class="el" href="PxGpuDispatcher_8h.html#ab946c7f02e09efd788a204718015d88a">CUstream</a> stream)=0</td></tr>
<tr class="memdesc:a7dbc8264abbffb8075f37e2d61205671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch a copy kernel with arbitrary number of copy commands.  <a href="#a7dbc8264abbffb8075f37e2d61205671">More...</a><br /></td></tr>
<tr class="separator:a7dbc8264abbffb8075f37e2d61205671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a12b661dab8671aaa9bd414c2b71440"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1PxBaseTask.html">PxBaseTask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#a3a12b661dab8671aaa9bd414c2b71440">getPreLaunchTask</a> ()=0</td></tr>
<tr class="memdesc:a3a12b661dab8671aaa9bd414c2b71440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query pre launch task that runs before launching gpu kernels.  <a href="#a3a12b661dab8671aaa9bd414c2b71440">More...</a><br /></td></tr>
<tr class="separator:a3a12b661dab8671aaa9bd414c2b71440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7086ea741a0e605ba51f012743180353"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#a7086ea741a0e605ba51f012743180353">addPreLaunchDependent</a> (<a class="el" href="classphysx_1_1PxBaseTask.html">PxBaseTask</a> &amp;dependent)=0</td></tr>
<tr class="memdesc:a7086ea741a0e605ba51f012743180353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a gpu launch task that gets executed after the pre launch task.  <a href="#a7086ea741a0e605ba51f012743180353">More...</a><br /></td></tr>
<tr class="separator:a7086ea741a0e605ba51f012743180353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c292cd7b8a431fa969116423e32254"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1PxBaseTask.html">PxBaseTask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#ae3c292cd7b8a431fa969116423e32254">getPostLaunchTask</a> ()=0</td></tr>
<tr class="memdesc:ae3c292cd7b8a431fa969116423e32254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query post launch task that runs after the gpu is done.  <a href="#ae3c292cd7b8a431fa969116423e32254">More...</a><br /></td></tr>
<tr class="separator:ae3c292cd7b8a431fa969116423e32254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac982dffd87d4252ea53906504d2cc349"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#ac982dffd87d4252ea53906504d2cc349">addPostLaunchDependent</a> (<a class="el" href="classphysx_1_1PxBaseTask.html">PxBaseTask</a> &amp;dependent)=0</td></tr>
<tr class="memdesc:ac982dffd87d4252ea53906504d2cc349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a task that gets executed after the post launch task.  <a href="#ac982dffd87d4252ea53906504d2cc349">More...</a><br /></td></tr>
<tr class="separator:ac982dffd87d4252ea53906504d2cc349"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a732e0687b5f29c5ec9cacf8674a0e805"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1PxGpuDispatcher.html#a732e0687b5f29c5ec9cacf8674a0e805">~PxGpuDispatcher</a> ()</td></tr>
<tr class="memdesc:a732e0687b5f29c5ec9cacf8674a0e805"><td class="mdescLeft">&#160;</td><td class="mdescRight">protected destructor  <a href="#a732e0687b5f29c5ec9cacf8674a0e805">More...</a><br /></td></tr>
<tr class="separator:a732e0687b5f29c5ec9cacf8674a0e805"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A GpuTask dispatcher. </p>
<p>A <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> executes GpuTasks submitted by one or more TaskManagers (one or more scenes). It maintains a CPU worker thread which waits on GpuTask "groups" to be submitted. The submission API is explicitly sessioned so that GpuTasks are dispatched together as a group whenever possible to improve parallelism on the GPU.</p>
<p>A <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> cannot be allocated ad-hoc, they are created as a result of creating a PxCudaContextManager. Every PxCudaContextManager has a <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> instance that can be queried. In this way, each <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> is tied to exactly one CUDA context.</p>
<p>A scene will use CPU fallback Tasks for GpuTasks if the <a class="el" href="classphysx_1_1PxTaskManager.html" title="The PxTaskManager interface. ">PxTaskManager</a> provided to it does not have a <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a>. For this reason, the <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> must be assigned to the <a class="el" href="classphysx_1_1PxTaskManager.html" title="The PxTaskManager interface. ">PxTaskManager</a> before the <a class="el" href="classphysx_1_1PxTaskManager.html" title="The PxTaskManager interface. ">PxTaskManager</a> is given to a scene.</p>
<p>Multiple TaskManagers may safely share a single <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> instance, thus enabling scenes to share a CUDA context.</p>
<p>Only <a class="el" href="classphysx_1_1PxGpuDispatcher.html#a3157fe3020f29f2a4c3bdc5eb11b79c6" title="Returns true if a CUDA call has returned a non-recoverable error. ">failureDetected()</a> is intended for use by the user. The rest of the nvGpuDispatcher public methods are reserved for internal use by only both TaskManagers and GpuTasks. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a732e0687b5f29c5ec9cacf8674a0e805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732e0687b5f29c5ec9cacf8674a0e805">&#9670;&nbsp;</a></span>~PxGpuDispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual physx::PxGpuDispatcher::~PxGpuDispatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>protected destructor </p>
<p>GpuDispatchers are allocated and freed by their PxCudaContextManager. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a27c2631f98a92733515f59823787fdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c2631f98a92733515f59823787fdc7">&#9670;&nbsp;</a></span>addCompletionPrereq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxGpuDispatcher::addCompletionPrereq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1PxBaseTask.html">PxBaseTask</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a CUDA completion prerequisite dependency to a task. </p>
<p>A GpuTask calls this function to add a prerequisite dependency on another task (usually a CpuTask) preventing that task from starting until all of the CUDA kernels and copies already launched have been completed. The <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> will increment that task's reference count, blocking its execution, until the CUDA work is complete.</p>
<p>This is generally only required when a CPU task is expecting the results of the CUDA kernels to have been copied into host memory.</p>
<p>This mechanism is not at all not required to ensure CUDA kernels and copies are issued in the correct order. Kernel issue order is determined by normal task dependencies. The rule of thumb is to only use a blocking completion prerequisite if the task in question depends on a completed GPU-&gt;Host DMA.</p>
<p>The <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> issues a blocking event record to CUDA for the purposes of tracking the already submitted CUDA work. When this event is resolved, the <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> manually decrements the reference count of the specified task, allowing it to execute (assuming it does not have other pending prerequisites). </p>

</div>
</div>
<a id="ac982dffd87d4252ea53906504d2cc349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac982dffd87d4252ea53906504d2cc349">&#9670;&nbsp;</a></span>addPostLaunchDependent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxGpuDispatcher::addPostLaunchDependent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1PxBaseTask.html">PxBaseTask</a> &amp;&#160;</td>
          <td class="paramname"><em>dependent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a task that gets executed after the post launch task. </p>
<p>This is part of an optional feature to schedule multiple gpu features at the same time to get kernels to run in parallel. </p><dl class="section note"><dt>Note</dt><dd>Each call adds a reference to the pre-launch task. </dd></dl>

</div>
</div>
<a id="a7086ea741a0e605ba51f012743180353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7086ea741a0e605ba51f012743180353">&#9670;&nbsp;</a></span>addPreLaunchDependent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxGpuDispatcher::addPreLaunchDependent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1PxBaseTask.html">PxBaseTask</a> &amp;&#160;</td>
          <td class="paramname"><em>dependent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a gpu launch task that gets executed after the pre launch task. </p>
<p>This is part of an optional feature to schedule multiple gpu features at the same time to get kernels to run in parallel. </p><dl class="section note"><dt>Note</dt><dd>Each call adds a reference to the pre-launch task. </dd></dl>

</div>
</div>
<a id="a3157fe3020f29f2a4c3bdc5eb11b79c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3157fe3020f29f2a4c3bdc5eb11b79c6">&#9670;&nbsp;</a></span>failureDetected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::PxGpuDispatcher::failureDetected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a CUDA call has returned a non-recoverable error. </p>
<p>A return value of true indicates a fatal error has occurred. To protect itself, the <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> enters a fall through mode that allows GpuTasks to complete without being executed. This allows simulations to continue but leaves GPU content static or corrupted.</p>
<p>The user may try to recover from these failures by deleting GPU content so the visual artifacts are minimized. But there is no way to recover the state of the GPU actors before the failure. Once a CUDA context is in this state, the only recourse is to create a new CUDA context, a new scene, and start over.</p>
<p>This is our "Best Effort" attempt to not turn a soft failure into a hard failure because continued use of a CUDA context after it has returned an error will usually result in a driver reset. However if the initial failure was serious enough, a reset may have already occurred by the time we learn of it. </p>

</div>
</div>
<a id="a2ec171af375195b782acce8fae4d2e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec171af375195b782acce8fae4d2e93">&#9670;&nbsp;</a></span>finishGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxGpuDispatcher::finishGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record the end of a GpuTask batch submission. </p>
<p>A <a class="el" href="classphysx_1_1PxTaskManager.html" title="The PxTaskManager interface. ">PxTaskManager</a> calls this function to notify the <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> that it is done submitting a group of GpuTasks (GpuTasks which were all make ready to run by the same prerequisite dependency becoming resolved). If no other group submissions are in progress, the <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> will execute the set of ready tasks. </p>

</div>
</div>
<a id="a0310275811d2b9df30ef6dfeda59333b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0310275811d2b9df30ef6dfeda59333b">&#9670;&nbsp;</a></span>forceFailureMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxGpuDispatcher::forceFailureMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force the <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> into failure mode. </p>
<p>This API should be used if user code detects a non-recoverable CUDA error. This ensures the <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> does not launch any further CUDA work. Subsequent calls to <a class="el" href="classphysx_1_1PxGpuDispatcher.html#a3157fe3020f29f2a4c3bdc5eb11b79c6" title="Returns true if a CUDA call has returned a non-recoverable error. ">failureDetected()</a> will return true. </p>

</div>
</div>
<a id="ad903de1449d82e6d9e51f610711f74d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad903de1449d82e6d9e51f610711f74d9">&#9670;&nbsp;</a></span>getCudaContextManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxCudaContextManager* physx::PxGpuDispatcher::getCudaContextManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the PxCudaContextManager associated with this <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a>. </p>
<p>Every PxCudaContextManager has one <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a>, and every <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> has one PxCudaContextManager. </p>

</div>
</div>
<a id="ae3c292cd7b8a431fa969116423e32254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c292cd7b8a431fa969116423e32254">&#9670;&nbsp;</a></span>getPostLaunchTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1PxBaseTask.html">PxBaseTask</a>&amp; physx::PxGpuDispatcher::getPostLaunchTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query post launch task that runs after the gpu is done. </p>
<p>This is part of an optional feature to schedule multiple gpu features at the same time to get kernels to run in parallel. </p><dl class="section note"><dt>Note</dt><dd>Do *not* set the continuation on the returned task, but use <a class="el" href="classphysx_1_1PxGpuDispatcher.html#ac982dffd87d4252ea53906504d2cc349" title="Adds a task that gets executed after the post launch task. ">addPostLaunchDependent()</a>. </dd></dl>

</div>
</div>
<a id="a3a12b661dab8671aaa9bd414c2b71440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a12b661dab8671aaa9bd414c2b71440">&#9670;&nbsp;</a></span>getPreLaunchTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1PxBaseTask.html">PxBaseTask</a>&amp; physx::PxGpuDispatcher::getPreLaunchTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query pre launch task that runs before launching gpu kernels. </p>
<p>This is part of an optional feature to schedule multiple gpu features at the same time to get kernels to run in parallel. </p><dl class="section note"><dt>Note</dt><dd>Do *not* set the continuation on the returned task, but use <a class="el" href="classphysx_1_1PxGpuDispatcher.html#a7086ea741a0e605ba51f012743180353" title="Adds a gpu launch task that gets executed after the pre launch task. ">addPreLaunchDependent()</a>. </dd></dl>

</div>
</div>
<a id="a7dbc8264abbffb8075f37e2d61205671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbc8264abbffb8075f37e2d61205671">&#9670;&nbsp;</a></span>launchCopyKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxGpuDispatcher::launchCopyKernel </td>
          <td>(</td>
          <td class="paramtype">PxGpuCopyDesc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxGpuDispatcher_8h.html#ab946c7f02e09efd788a204718015d88a">CUstream</a>&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Launch a copy kernel with arbitrary number of copy commands. </p>
<p>This method is intended to be called from Kernel GpuTasks, but it can function outside of that context as well.</p>
<p>If count is 1, the descriptor is passed to the kernel as arguments, so it may be declared on the stack.</p>
<p>If count is greater than 1, the kernel will read the descriptors out of host memory. Because of this, the descriptor array must be located in page locked (pinned) memory. The provided descriptors may be modified by this method (converting host pointers to their GPU mapped equivalents) and should be considered *owned* by CUDA until the current batch of work has completed, so descriptor arrays should not be freed or modified until you have received a completion notification.</p>
<p>If your GPU does not support mapping of page locked memory (SM&gt;=1.1), this function degrades to calling CUDA copy methods. </p>

</div>
</div>
<a id="a86f6db8b18cf8380967890d694e3df8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f6db8b18cf8380967890d694e3df8e">&#9670;&nbsp;</a></span>startGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxGpuDispatcher::startGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record the start of a GpuTask batch submission. </p>
<p>A <a class="el" href="classphysx_1_1PxTaskManager.html" title="The PxTaskManager interface. ">PxTaskManager</a> calls this function to notify the <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> that one or more GpuTasks are about to be submitted for execution. The <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> will not read the incoming task queue until it receives one <a class="el" href="classphysx_1_1PxGpuDispatcher.html#a2ec171af375195b782acce8fae4d2e93" title="Record the end of a GpuTask batch submission. ">finishGroup()</a> call for each <a class="el" href="classphysx_1_1PxGpuDispatcher.html#a86f6db8b18cf8380967890d694e3df8e" title="Record the start of a GpuTask batch submission. ">startGroup()</a> call. This is to ensure as many GpuTasks as possible are executed together as a group, generating optimal parallelism on the GPU. </p>

</div>
</div>
<a id="a091cb121a38ddf39fcab51f5118a15d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091cb121a38ddf39fcab51f5118a15d2">&#9670;&nbsp;</a></span>startSimulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxGpuDispatcher::startSimulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record the start of a simulation step. </p>
<p>A <a class="el" href="classphysx_1_1PxTaskManager.html" title="The PxTaskManager interface. ">PxTaskManager</a> calls this function to record the beginning of a simulation step. The <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> uses this notification to initialize the profiler state. </p>

</div>
</div>
<a id="ab46896dea09105e1f5fc1d19a98f2b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46896dea09105e1f5fc1d19a98f2b1b">&#9670;&nbsp;</a></span>stopSimulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxGpuDispatcher::stopSimulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record the end of a simulation frame. </p>
<p>A <a class="el" href="classphysx_1_1PxTaskManager.html" title="The PxTaskManager interface. ">PxTaskManager</a> calls this function to record the completion of its dependency graph. If profiling is enabled, the <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> will trigger the retrieval of profiling data from the GPU at this point. </p>

</div>
</div>
<a id="a5ffc5d0c124afbcad0b6fcf1080af5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffc5d0c124afbcad0b6fcf1080af5ee">&#9670;&nbsp;</a></span>submitTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxGpuDispatcher::submitTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1PxTask.html">PxTask</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a GpuTask for execution. </p>
<p>Submitted tasks are pushed onto an incoming queue. The <a class="el" href="classphysx_1_1PxGpuDispatcher.html" title="A GpuTask dispatcher. ">PxGpuDispatcher</a> will take the contents of this queue every time the pending group count reaches 0 and run the group of submitted GpuTasks as an interleaved group. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxGpuDispatcher_8h_source.html">PxGpuDispatcher.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacephysx.html">physx</a></li><li class="navelem"><a class="el" href="classphysx_1_1PxGpuDispatcher.html">PxGpuDispatcher</a></li>
    <li class="footer">Copyright &copy; 2008-2018 NVIDIA Corporation, 2788 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a></li>
  </ul>
</div>
</body>
</html>
